vector<double> gauss_seidel(SparseMatrix<double>& A, vector<double>& b, double tol, int iter){
   SparseMatrix<double> T = inv(triangInf(A));
   vector<double> c = T @ b;
   SparseMatrix<double> R = triangSup(A) - diag(A);
 
   vector<double> x = randomVector(A.size());
   bool b = true;
   for(int i = 0; i < iter && b; ++i){
       vector<double> y = T @ (R @ x) + c;
       if(abs(x - y) < tol) b = false;
       x = y;
   }
 
   return x;
}


vector<double> jacobi(SparseMatrix<double>& A, vector<double>& b, double tol, int iter){
   SparseMatrix<double> T = inv(diag(A));
   vector<double> c = T @ b;
   SparseMatrix<double> R =  -(triangSup(A) + triangInf(A))
 
   vector<double> x = randomVector(A.size());
   bool b = true;
   for(int i = 0; i < iter && b; ++i){
       vector<double> y = T @ (R @ x) + c;
       if(abs(x - y) < tol) b = false;
       x = y;
   }
 
   return x;
}


void metnum::eliminacion_gaussiana(Eigen::SparseMatrix<double, Eigen::RowMajor> &A, Eigen::VectorXd &b) {
      // pre: A_ii != 0 para i: 0 ... N. hasta el final de la eliminaci贸n
      //     b.size() == A.cols() == A.rows()

     Eigen::SparseMatrix<double> B = A;

     int n = B.rows();

     for(int i = 0; i < n; ++i){
         std::vector<Eigen::Triplet<double>> M_list;
         for(int j = 0; j < n; ++j)
             M_list.emplace_back(Eigen::Triplet<double> {j, j, 1});

         Eigen::SparseMatrix<double>::InnerIterator it(B, i);
         while(it.row() < i) ++it;
         double mii = it.value();
         ++it;
         for ( ; it ; ++it)
             M_list.emplace_back(Eigen::Triplet<double> {it.row(), i, -it.value() / mii});

         Eigen::SparseMatrix<double> M{(Eigen::Index) n, (Eigen::Index) n};
         M.setFromTriplets(M_list.begin(), M_list.end());
         B = (M * B).pruned(1e-3);
         b = M * b;
     }
     A = B;
}


void metnum::eliminacion_gaussiana(Eigen::SparseMatrix<double, Eigen::RowMajor> &A, Eigen::VectorXd &b) {
    // pre: A_ii != 0 para i: 0 ... N. hasta el final de la eliminaci贸n
    //      b.size() == A.cols() == A.rows()

    for (int i = 0; i < A.rows() - 1; ++i) {
        // printM(A);
        double mii = A.coeff(i, i);
        for(int j = i+1; j < A.rows(); ++j){
            double mij = A.coeff(j, i) / mii;
            if(mij == 0) continue;
            for(Eigen::SparseMatrix<double, Eigen::RowMajor>::InnerIterator it_fila_i(A, i); it_fila_i; ++it_fila_i){
                A.coeffRef(j, it_fila_i.col()) -= it_fila_i.value() * mij;
            }
            b[j] = b[j] - b[i] * mij;
        }
        A.makeCompressed();
    }
}


void metnum::eliminacion_gaussiana(Eigen::SparseMatrix<double> &A, Eigen::VectorXd &b) {
    // pre: A_ii != 0 para i: 0 ... N. hasta el final de la eliminaci贸n
    //      b.size() == A.cols() == A.rows()
    size_t n = A.cols();
    Eigen::SparseMatrix<double, Eigen::RowMajor> M(A.rows(), A.cols());

    std::vector<Eigen::Triplet<double>> t_list;
    t_list.reserve(A.rows() * 2);
    for (int k = 0; k < n; ++k) {
        t_list.emplace_back(Eigen::Triplet<double>{k, k, 1});
    }
    size_t pos = n;

    for (int i = 0; i < A.rows() - 1; ++i) {
        for (Eigen::SparseMatrix<double>::InnerIterator it(A, i); it; ++it) {
             M
            int k = it.row();
            if (k <= i) {
                continue;
            }
            double mij = - A.coeff(k, i) / A.coeff(i, i);
            t_list[pos] = Eigen::Triplet<double>{k, i, mij};
            pos++;

            b[k] = b[k] + b[i] * mij;
        }
        M.setFromTriplets(t_list.begin(), t_list.begin() + pos);
        pos = n;

        A = (M * A).pruned(1e-4);
    }
}


void metnum::eliminacion_gaussiana(Eigen::SparseMatrix<double> &A, Eigen::VectorXd &b) {
     // pre: A_ii != 0 para i: 0 ... N. hasta el final de la eliminaci贸n
     //      b.size() == A.cols() == A.rows()
     Eigen::SparseMatrix<double, Eigen::RowMajor> B = A;

     std::vector<int> p_list;
     p_list.reserve(A.rows());
     int p_pos = 0;

     for (int i = 0; i < A.rows() - 1; ++i) {
         for (Eigen::SparseMatrix<double>::InnerIterator it(A, i); it; ++it) {
              M
             int k = it.row();
             if (k <= i) {
                 continue;
             }
             p_list[p_pos] = k;
             p_pos++;
         }
         while(p_pos > 0) {
             int j = p_list[p_pos - 1];
             double mij = A.coeff(j, i) / A.coeff(i, i);
             for (Eigen::SparseMatrix<double, Eigen::RowMajor>::InnerIterator it(B, i); it; ++it) {
                 int k = it.col();
                 if (k < i) {
                     continue;
                 }
                 double val = A.coeff(j, k) - A.coeff(i, k) * mij;
                 A.coeffRef(j, k) = val;
             }
             b[j] = b[j] - b[i] * mij;
             --p_pos;
         }
         B = A;
     }
}
